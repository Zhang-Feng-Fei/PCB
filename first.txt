小结：现在总结一下今天学的两点内容：
1、初始化一个Git仓库，使用git init命令；
2、添加文件到Git仓库，分两步：
1）使用命令git add <file>，注意，可反复多次使用，添加多个文件，实际上就是把文件修改添加到暂存区；
2）使用命令git commit -m <message>，完成，实际上就是把暂存区的所有内容提交到当前分支，提交后暂存区就变成空白了（见picture3）。
注：因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改；
注：Git管理的是修改，而不是文件。

小结
1、要随时掌握工作区的状态，使用git status命令，实际上就是查看暂存区的状态。（见picture2）
2、如果git status告诉你有文件被修改过，用git diff可以查看修改内容；
3、git diff HEAD -- first.txt命令可以查看工作区和版本库里面最新版本的区别

小结
1、HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id；例子：$ git reset --hard HEAD^；
2、上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100；
3、回到之后的版本：$ git reset --hard 1094a（版本号）；
4、穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本；
5、如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数：$ git log --pretty=oneline；
6、要重返未来，用git reflog查看操作的命令历史，以便确定要回到未来的哪个版本。

小结
1、Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。（见picture1）

小结
1、若未添加到暂存区，想退回到修改前：$ git checkout -- test.txt可以把test.txt在工作区的修改全部撤销；
2、若已添加到暂存区，想退回到修改前；首先git reset HEAD <file>可以把暂存区修改重新放回到工作区，然后同第1不操作；
3、若暂存区提交到了版本库，想退回到修改前，可回退到上一个版本。前提是本地版本库还未推送到远程。
注：就是让这个文件回到最近一次git commit或git add时的状态。

小结
1、工作区文件删错了，可把版本库内的文件恢复到工作区：$ git checkout -- test.txt；
2、git checkout其实是用版本库里的版本替换工作区的版本。
注：从来没有被添加到版本库就被删除的文件，是无法恢复的！
注：只能恢复文件到最新版本，会丢失最近一次提交后修改的内容。

注：
1、工作区：相当于windows系统中的一个文件夹；
2、工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库；
3、版本库管理着工作区中文件的历次改动信息；
4、删除文件也是一种修改，也需要进行git add 与 git commit -m操作或者git rm 与 git commit -m从版本库中删除该文件。






1、只要注册一个GitHub账号，就可以免费获得Git远程仓库；
2、注册GitHub账号；
3、本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，需要以下操作：
1）创建SSH Key：打开Shell（Windows下打开Git Bash），敲击指令：$ ssh-keygen -t rsa -C "youremail@example.com"；
注：然后一路回车，使用默认值即可，也无需设置密码；之后用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。
2）登陆GitHub，打开“Account settings”，“SSH Keys”页面----点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容：（见picture4）
注：因GitHub需要识别出你推送的提交确实是你推送的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送；当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。
注：GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）；有两个办法让别人看不见：一个是交点保护费，让GitHub把公开的仓库变成私有的，另一个办法是自己动手搭一个Git服务器。


添加远程仓库：
1、登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库（见picture5）
2、在Repository name填入本地仓库的名字，其他保持默认设置，点击“Create repository”按钮；
1）远程仓库克隆出新的仓库
2）可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库，在本地的learngit仓库下运行下面的命令
例子：
git remote add origin https://github.com/Zhang-Feng-Fei/PCB.git
git branch -M master
git push -u origin master
注：请千万注意，把上面的michaelliao替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。（这个可以不看）
注：添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。
注：把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。
注;由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。
3）从现在起，只要本地作了提交，就可以通过命令：$ git push origin master

注：
SSH警告：当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告：这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。
Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：这个警告只会出现一次，后面的操作就不会有任何警告了。如果你实在担心有人冒充GitHub服务器，输入yes前可以对照GitHub的RSA Key的指纹信息是否与SSH连接给出的一致。

1、先创建远程库，然后从远程库克隆
2、登陆GitHub，创建一个新的仓库，名字叫gitskills：（见picture6）
3、远程库gitskills已经准备好了，下一步是用命令git clone克隆出一个本地库：git clone https://github.com/Zhang-Feng-Fei/gitskills.git（这个是抓取或推送的远程仓库地址）
注：GitHub给出的地址不止一个，还可以用git@github.com:Zhang-Feng-Fei/gitskills.git，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议，使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。


分支：
1、master分支（主分支）。HEAD严格来说不是指向提交，而是指向master，master（主分支）才是指向提交的，所以，HEAD指向的就是当前分支（见picture7）
2、Git新建了一个指针叫dev（分支），指向master相同的提交，再把HEAD指向dev，HEAD指向当前分支是dev：（见picture8）
注：Git创建一个分支：增加一个dev指针，改边HEAD的指向
3、执行分支工作时（见picture9）
4、dev分支工作完成后，把dev分支合并到master主分支上（见picture10）；注：就改改指针，工作区内容也不变！
5、合并完分支后，可以删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支（见picture11）；
创建、删除、合并分支的指令：
1、创建并切换到分支：$ git checkout -b dev或者$ git switch -c dev  注：在cmd界面输入
注：相当于以下2条指令
$ git branch dev
$ git checkout dev
2、查看当前分支：$ git branch
3、在当前分支进行文件的修改、提交工作$ git add readme.txt 、$ git commit -m "branch test"
4、分支切换到主分支$ git checkout master或者$ git switch master；分支不同的相同文件，文件内容是不同的；（见picture12）
5、分支合并到主分支上$ git merge dev；注：合并前需要将分支及主分支上的文件都提交，才能正常合并
注：Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快；当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。
6、删除分支：$ git branch -D dev（强制删除）；$ git branch -d dev（有条件删除，前提是合并完成的分支）

1、两分支中都对文件进行了修改，并且都进行了提交，会变成（见picture13）图中样式；
2、这种情况分支无法快速合并，快速合并会有冲突；$ git merge feature1或$ git status可以查看冲突文件
3、两个分支相同文件冲突的解决办法：这个时候两个分支修改的内容自动填充进来，用<<<<<<<，=======，>>>>>>>标记出不同分支的内容
4、这个时候可以修改文件内容与一个分支的文件一致，然后提交不一致的分支；
5、最后再进行合并（见picture14）
6、用带参数的git log也可以看到分支的合并情况：$ git log --graph --pretty=oneline --abbrev-commit 或git log --pretty=oneline --abbrev-commit
注：合并了不删除分支还是存在的，不是合并后分支就自动消失了，合并只是把两个分支相同的文件的内容整合到一起
注：解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交


1、分支合并时，默认Fast forward模式，缺点：分支删掉后分支信息会丢失
2、可强制禁用Fast forward模式，在merge（合并）时生成一个新commit，当git log（查看分支历史）时，即使分支删掉也可以看到分支修改的一系列信息。（见picture15）
方法：git merge --no-ff -m "merge with no-ff" dev；注：--no-ff就是强制禁用Fast forward模式，-m "merge with no-ff"就是生成一个新的commit
分支管理基本原则：
1、master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；
2、都在dev分支上干活，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；
3、你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。
4、团队合作的分支看起来就像这样（见picture16）。

Bug分支
1、遇到Bug时，新建Bug临时分支，修改完Bug后合并，删除Bug分支
2、当工作区仍未提交（比如：工作只进行到一半，但这时需要先修改Bug），使用：$ git stash，将工作区保存起来（就是将文件中还未提交到暂存区的内容保存到其它地方，此时文件中没有了之前编辑且还在工作区的内容）
3、这样就可以修复更久之前编辑内容中的Bug：
1）切换主分支——创建并切换进Bug分支
2）修改完Bug后，保存——提交工作区——提交暂存区——提交进库
3）切换到主分支——合并Bug分支——删除Bug分支
4）使用Bug分支修改完主分支的Bug后，切换dev进分支——接着干分支的活

5）查看之前dev分支保存的工作区的内容现在在哪：$ git stash list
6）恢复保存内容到dev分支的工作区：git stash apply（不删除保存区内容，可用git stash drop去删除）或git stash pop（同时删除保存区内容）
7）若进行过多次git stash，可指定删除哪个stash： git stash apply stash@{0}

4、主分支修改完Bug，怎样修改dev分支同样的Bug：$ git cherry-pick 4c805e2（主分支修改这次Bug所起的名字）
注：dev分支改动名字，与主分支改动名字是不一样的，虽然两个改动的是同一个地方，改动的内容也相同


注：只有文件保存后（编辑内容才会进工作区），工作区的文件才真正被认定为修改，才能传进暂存区，最后提交进库中
注：只在一个分支修改（主分支也不修改时），回到主分支后，可以直接合并分支进主分支

注：Git还会自动提示我们当前master分支比远程的master分支要超前1个提交。



Feature分支
1、程序每添加一个新功能，最好新建一个feature分支：在该分支上开发，完成后合并进主分支，最后删除该分支；
流程：新建并打开分支——开发完成——提交——切换进主分支——合并新建分支——删除新建分支

多人协作
1、查看远程仓库信息：git remote或git remote -v（没有权限是看不到push的地址）
2、远程仓库默认名称：origin
3、推送分支到远程分支：$ git push origin master
注：需要推送的分支master、dev（开发分支，团队所有成员都需要在上面工作）
注：bug（除非老板要看看你每周到底修复了几个bug）、feature（你是否和你的小伙伴合作在上面开发）可不推送
4、抓取远程分支到本地：git clone https://github.com/Zhang-Feng-Fei/gitskills.git，只能抓取maste分支
5、进本地创建打开dev分支，并抓取远程dev分支：git checkout -b dev origin/dev
6、dev分支推送：指定本地dev分支与远程origin/dev分支的链接（git branch --set-upstream-to=origin/dev dev）——把最新的提交从origin/dev抓取下来（git pull）——解决冲突然后在本地合并——提交并推送（git commit -m "fix env conflict"、git push origin dev）
注：无法向远程库分支推送本地分支的原因：是远程分支已经被其它人率先改变，所以必须先解决本地分支与远程分支的冲突
注：提交：就是把工作区文件放进暂存区：可用git add 或 合并提交

Rebase
1、把分叉的提交变成直线：git rebase；就是本地提交与远程抓取到的提交分成了2个支路，使用该指令，会将当前抓取的别人的远程提交放在本地提交前，自己的远程提交之后，并合并成一条分支（见picture17）
注：Git把我们本地的提交“挪动”了位置，放到了最新抓取的新远程提交之后；
注：rebase操作前后，最终的提交内容是一致的；
注：本地commit修改内容已经变化了，它们的修改不再基于之前抓取的远程提交，而是基于最新抓取的远程提交；
缺点：本地的分叉提交已经被修改过了。
注：分叉的提交需要三方对比。

注意：本地库名、远程库名、分支名、分支的最新提交位置、本地分支可以比远程分支早提交几个改变（比如：用户自己的本地提交，或者用户远程抓取的别人的提交，都会改变本地提交次数，但自己记录的远程提交还没修改）


标签：
1、Git的标签（tag）虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动）
2、所以，创建和删除标签都是瞬间完成的；
作用：快速找到之前版本

创建标签：切换到需要打标签的分支上——打一个新标签（git tag v1.0）
查看所有标签：git tag
历史提交的commit id打标签：git tag v0.9 f52c633（需要打标签的commit id）
查看标签信息：git show v0.9（标签名）
创建带有说明的标签：git tag -a v0.1 -m "version 0.1 released" 1094adb（-a指定标签名，-m指定说明文字）
注：默认标签是打在最新提交的commit上的
注：标签不是按时间顺序列出，而是按字母排序的
注：如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签

操作标签
删除标签：git tag -d v0.1
标签推送到远程：git push origin v1.0
一次性推送全部尚未推送到远程的本地标签：git push origin --tags
删除远程标签：先删除本地标签git tag -d v0.9，然后远程删除标签git push origin :refs/tags/v0.9
注：创建的标签都只存储在本地，不会自动推送到远程


使用GitHub
github上克隆别人开源的项目（仓库）
1、进入别人的github库，登录自己的github账号，点“Fork”就在自己的github账号下克隆该开源的项目（仓库）（见picture18）
2、然后要从自己的账号下clone仓库（才能推送修改）：git clone https://github.com/Zhang-Feng-Fei/bootstrap.git
注：Bootstrap的官方仓库twbs/bootstrap、你在GitHub上克隆的仓库my/bootstrap，以及你自己克隆到本地电脑的仓库，他们的关系（见picture19）
注：修改了bootstrap后，可自己的bootstrap仓库推送。如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。当然，对方是否接受你的pull request就不一定了。（见picture20）

使用Gitee











详见网址：https://www.liaoxuefeng.com/wiki/896043488029600/900004111093344